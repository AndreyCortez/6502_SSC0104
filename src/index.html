<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content=
		"width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../stylesheets/styles.css">
    <link rel="stylesheet" href="../simulator/style.css">
    <style>
    body {
        background-color: #07497b;
        text-align: center;
    }

    @font-face {
    font-family: myFirstFont;
    src: url(../font/Silkscreen-Regular.ttf);
    }
  
    h1 {
    font-family: myFirstFont;
    color: #6ca4d4;
    }

    p {
    font-family: myFirstFont;
    color: #6ca4d4;
    }

    .container {
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .container img{
        margin: 20px;
    }
    </style>
</head>

<body>
<h1>*** 6502 ***</h1>

<p>O 6502 é um microprocessador de 8 bits que foi lançado em 1975 pela MOS Technology.
     Ele foi um dos primeiros microprocessadores amplamente utilizados em computadores domésticos 
     e sistemas embutidos durante a década de 1970 e início da década de 1980.</p>
<div class="container">
    <img src="../Images/mario.png" width="300" height="200">
    <img src="../Images/pacman.png" width="200" height="200">
</div>

<p>O 6502 teve um impacto significativo na indústria da computação devido à sua arquitetura eficiente
     e acessível. Ele foi projetado para ser usado em uma ampla variedade de aplicações e se tornou 
     uma escolha popular para muitos fabricantes de computadores e consoles de jogos da época.</p>

<p>Uma das características notáveis do 6502 é o seu conjunto de instruções compacto, que permitia um 
    código otimizado e um melhor uso da memória disponível. O processador também possuía um barramento de 
    dados de 8 bits e um barramento de endereço de 16 bits, o que permitia acessar até 64 KB de memória. Além 
    disso, o 6502 possuía um conjunto básico de registradores, como o acumulador (A), o registrador 
    de índice X, o registrador de índice Y e um registrador de status que continha várias flags para
     indicar condições como overflow, zero, negativo, entre outras.</p>


     <div class="widget">
        <div class="buttons">
          <input type="button" value="Assemble" class="assembleButton" />
          <input type="button" value="Run" class="runButton" />
          <input type="button" value="Reset" class="resetButton" />
          <input type="button" value="Hexdump" class="hexdumpButton" />
          <input type="button" value="Disassemble" class="disassembleButton" />
          <input type="button" value="Notes" class="notesButton" />
        </div>
      
        <textarea class="code">
;  ___           _        __ ___  __ ___
; / __|_ _  __ _| |_____ / /| __|/  \_  )
; \__ \ ' \/ _` | / / -_) _ \__ \ () / /
; |___/_||_\__,_|_\_\___\___/___/\__/___|

; Change direction: W A S D

define appleL         $00 ; screen location of apple, low byte
define appleH         $01 ; screen location of apple, high byte
define snakeHeadL     $10 ; screen location of snake head, low byte
define snakeHeadH     $11 ; screen location of snake head, high byte
define snakeBodyStart $12 ; start of snake body byte pairs
define snakeDirection $02 ; direction (possible values are below)
define snakeLength    $03 ; snake length, in bytes

; Directions (each using a separate bit)
define movingUp      1
define movingRight   2
define movingDown    4
define movingLeft    8

; ASCII values of keys controlling the snake
define ASCII_w      $77
define ASCII_a      $61
define ASCII_s      $73
define ASCII_d      $64

; System variables
define sysRandom    $fe
define sysLastKey   $ff


  jsr init
  jsr loop

init:
  jsr initSnake
  jsr generateApplePosition
  rts


initSnake:
  lda #movingRight  ;start direction
  sta snakeDirection

  lda #4  ;start length (2 segments)
  sta snakeLength
  
  lda #$11
  sta snakeHeadL
  
  lda #$10
  sta snakeBodyStart
  
  lda #$0f
  sta $14 ; body segment 1
  
  lda #$04
  sta snakeHeadH
  sta $13 ; body segment 1
  sta $15 ; body segment 2
  rts


generateApplePosition:
  ;load a new random byte into $00
  lda sysRandom
  sta appleL

  ;load a new random number from 2 to 5 into $01
  lda sysRandom
  and #$03 ;mask out lowest 2 bits
  clc
  adc #2
  sta appleH

  rts


loop:
  jsr readKeys
  jsr checkCollision
  jsr updateSnake
  jsr drawApple
  jsr drawSnake
  jsr spinWheels
  jmp loop


readKeys:
  lda sysLastKey
  cmp #ASCII_w
  beq upKey
  cmp #ASCII_d
  beq rightKey
  cmp #ASCII_s
  beq downKey
  cmp #ASCII_a
  beq leftKey
  rts
upKey:
  lda #movingDown
  bit snakeDirection
  bne illegalMove

  lda #movingUp
  sta snakeDirection
  rts
rightKey:
  lda #movingLeft
  bit snakeDirection
  bne illegalMove

  lda #movingRight
  sta snakeDirection
  rts
downKey:
  lda #movingUp
  bit snakeDirection
  bne illegalMove

  lda #movingDown
  sta snakeDirection
  rts
leftKey:
  lda #movingRight
  bit snakeDirection
  bne illegalMove

  lda #movingLeft
  sta snakeDirection
  rts
illegalMove:
  rts


checkCollision:
  jsr checkAppleCollision
  jsr checkSnakeCollision
  rts


checkAppleCollision:
  lda appleL
  cmp snakeHeadL
  bne doneCheckingAppleCollision
  lda appleH
  cmp snakeHeadH
  bne doneCheckingAppleCollision

  ;eat apple
  inc snakeLength
  inc snakeLength ;increase length
  jsr generateApplePosition
doneCheckingAppleCollision:
  rts


checkSnakeCollision:
  ldx #2 ;start with second segment
snakeCollisionLoop:
  lda snakeHeadL,x
  cmp snakeHeadL
  bne continueCollisionLoop

maybeCollided:
  lda snakeHeadH,x
  cmp snakeHeadH
  beq didCollide

continueCollisionLoop:
  inx
  inx
  cpx snakeLength          ;got to last section with no collision
  beq didntCollide
  jmp snakeCollisionLoop

didCollide:
  jmp gameOver
didntCollide:
  rts


updateSnake:
  ldx snakeLength
  dex
  txa
updateloop:
  lda snakeHeadL,x
  sta snakeBodyStart,x
  dex
  bpl updateloop

  lda snakeDirection
  lsr
  bcs up
  lsr
  bcs right
  lsr
  bcs down
  lsr
  bcs left
up:
  lda snakeHeadL
  sec
  sbc #$20
  sta snakeHeadL
  bcc upup
  rts
upup:
  dec snakeHeadH
  lda #$1
  cmp snakeHeadH
  beq collision
  rts
right:
  inc snakeHeadL
  lda #$1f
  bit snakeHeadL
  beq collision
  rts
down:
  lda snakeHeadL
  clc
  adc #$20
  sta snakeHeadL
  bcs downdown
  rts
downdown:
  inc snakeHeadH
  lda #$6
  cmp snakeHeadH
  beq collision
  rts
left:
  dec snakeHeadL
  lda snakeHeadL
  and #$1f
  cmp #$1f
  beq collision
  rts
collision:
  jmp gameOver


drawApple:
  ldy #0
  lda sysRandom
  sta (appleL),y
  rts


drawSnake:
  ldx snakeLength
  lda #0
  sta (snakeHeadL,x) ; erase end of tail

  ldx #0
  lda #1
  sta (snakeHeadL,x) ; paint head
  rts


spinWheels:
  ldx #0
spinloop:
  nop
  nop
  dex
  bne spinloop
  rts


gameOver:

        </textarea>
      
        <canvas class="screen" width="160" height="160"></canvas>
      
        <div class="debugger">
          <input type="checkbox" class="debug" name="debug" />
          <label for="debug">Debugger</label>
          <div class="minidebugger"></div>
          <div class="buttons">
            <input type="button" value="Step" class="stepButton" />
            <input type="button" value="Jump to..." class="gotoButton" />
          </div>
        </div>
      
        <div class="monitorControls">
          <label for="monitoring">Monitor</label>
          <input type="checkbox" class="monitoring" name="monitoring" />
      
          <label for="start">Start: $</label>
          <input type="text" value="0" class="start" name="start" />
          <label for="length">Length: $</label>
          <input type="text" value="ff" class="length" name="length" />
        </div>
      
        <div class="monitor"><pre><code></code></pre></div>
        <div class="messages"><pre><code></code></pre></div>
      
        <div class="notes" style="display: none">Notes:
      
      Memory location $fe contains a new random byte on every instruction.
      Memory location $ff contains the ascii code of the last key pressed.
      
      Memory locations $200 to $5ff map to the screen pixels. Different values will
      draw different colour pixels. The colours are:
      
      $0: Black
      $1: White
      $2: Red
      $3: Cyan
      $4: Purple
      $5: Green
      $6: Blue
      $7: Yellow
      $8: Orange
      $9: Brown
      $a: Light red
      $b: Dark grey
      $c: Grey
      $d: Light green
      $e: Light blue
      $f: Light grey
          </div>
      </div>

      <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script src="../simulator/es5-shim.js"></script>
    <script src="../simulator/assembler.js"></script>
    <script src="../javascripts/scale.fix.js"></script>
    <script type="text/javascript">
      var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
      document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
      try {
        var pageTracker = _gat._getTracker("UA-3174668-13");
      pageTracker._trackPageview();
      } catch(err) {}
    </script>

</body>
</html>
